#1
char Aclass(3,24)
Adymosim
1.4
Modelica experiment file


#    Experiment parameters
double experiment(7,1)
       0                   # StartTime    Time at which integration starts
                           #              (and linearization and trimming time)
      50                   # StopTime     Time at which integration stops
  1.0000000000000000E-03   # Increment    Communication step size, if > 0
       0                   # nInterval    Number of communication intervals, if > 0
  9.9999999999999995E-07   # Tolerance    Relative precision of signals for
                           #              simulation, linearization and trimming
       0                   # MaxFixedStep Maximum step size of fixed step size
                           #              integrators, if > 0.0
       8                   # Algorithm    Integration algorithm as integer (1...28)
                           #
                           #             | model|       |        | dense | state |
                           # Algorithm   | typ  | stiff | order  | output| event |
                           # ------------+------+-------+--------+-------+-------+
                           #  1 | deabm  |  ode |   no  |  1-12  |  yes  |   no  |
                           #  2 | lsode1 |  ode |   no  |  1-12  |  yes  |   no  |
                           #  3 | lsode2 |  ode |  yes  |  1-5   |  yes  |   no  |
                           #  4 | lsodar |  ode |  both |1-12,1-5|  yes  |  yes  |
                           #  5 | dopri5 |  ode |   no  |   5    |   no  |   no  |
                           #  6 | dopri8 |  ode |   no  |   8    |   no  |   no  |
                           #  7 | grk4t  |  ode |  yes  |   4    |   no  |   no  |
                           #  8 | dassl  |  dae |  yes  |  1-5   |  yes  |  yes  |
                           #  9 | odassl | hdae |  yes  |  1-5   |  yes  |  yes  |
                           # 10 | mexx   | hdae |   no  |  2-24  |   no  |   no  |
                           # 11 | euler  |  ode |   no  |   1    |   no  |  yes  |
                           # 12 | rkfix2 |  ode |   no  |   2    |   no  |  yes  |
                           # 13 | rkfix3 |  ode |   no  |   3    |   no  |  yes  |
                           # 14 | rkfix4 |  ode |   no  |   4    |   no  |  yes  |
                           #>=14| others |  ode |yes/no |  2-5   |   yes |  yes  |
                           # ---+--------+------+-------+--------+-------+-------+
                           # euler and rkfix have fixed stepsize.


#    Method tuning parameters
double method(27,1)
       1                   # grid     type of communication time grid, defined by
                           #          = 1: equidistant points ("Increment/nInterval")
                           #          = 2: vector of grid points ("tgrid")
                           #          = 3: variable step integrator (automatically)
                           #          = 4: model (call of "increment" in Dymola, e.g.
                           #                      incr=Time > 2 then 0 else 0.1
                           #                      dummy=increment(incr))
                           #          grid = 1,3 is stopped by "StopTime"
                           #          grid = 2   is stopped by "tgrid(last)"
                           #          grid = 4   runs forever (stopped by model)
       1                   # nt       Use every NT time instant, if grid = 3
       3                   # dense    1/2/3 restart/step/interpolate GRID points
       1                   # evgrid   0/1 do not/save event points in comm. time grid
       1                   # evu      0/1 U-discontinuity does not/trigger events
       0                   # evuord       U-discontinuity order to consider (0,1,...)
       0                   # error    0/1/2 One message/warning/error messages
       0                   # jac      0/1 Compute jacobian numerically/by BLOCKJ
       0                   # xd0c     0/1 Compute/set XD0
       0                   # f3       0/1 Ignore/use F3 of HDAE (= index 1)
       0                   # f4       0/1 Ignore/use F4 of HDAE (= index 2)
       0                   # f5       0/1 Ignore/use F5 of HDAE (= invar.)
       0                   # debug    flags for debug information (1<<0 uses pdebug) 
     100                   # pdebug       priority of debug information (1...100)
       0                   # fmax     Maximum number of evaluations of BLOCKF, if > 0
       0                   # ordmax   Maximum allowed integration order, if > 0
       0                   # hmax     Maximum absolute stepsize, if > 0
       0                   # hmin     Minimum absolute stepsize, if > 0 (use with care!)
       0                   # h0       Stepsize to be attempted on first step, if > 0
  2.0000000000000000E-14   # teps     Bound to check, if 2 equal time instants
  1.0000000000000000E-10   # eveps    Hysteresis epsilon at event points
      20                   # eviter   Maximum number of event iterations
  9.9999999999999995E-07   # delaym   Minimum time increment in delay buffers
       1                   # fexcep   0/1 floating exception crashes/stops dymosim
       1                   # tscale   clock-time = tscale*simulation-time, if grid = 5
                           #          > 1: simulation too slow
                           #          = 1: simulation-time = real-time
                           #          < 1: simulation too fast
       1                   # shared   (not used)
    2473                   # memkey   (not used)


#    Output parameters
int settings(13,1)
 0                         # lprec    0/1 do not/store result data in double
 1                         # lx       0/1 do not/store x  (state variables)
 1                         # lxd      0/1 do not/store xd (derivative of states)
 1                         # lu       0/1 do not/store u  (input     signals)
 1                         # ly       0/1 do not/store y  (output    signals)
 0                         # lz       0/1 do not/store z  (indicator signals)
 1                         # lw       0/1 do not/store w  (auxiliary signals)
 1                         # la       0/1 do not/store a  (alias     signals)
 0                         # lperf    0/1 do not/store performance indicators
 0                         # levent   0/1 do not/store event point
 1                         # lres     0/1 do not/store results on result file
 0                         # lshare   0/1 do not/store info data for shared memory on dsshare.txt
 1                         # lform    0/1 ASCII/Matlab-binary storage format of results
                           #              (for simulation/linearization; not for trimming)


#    Names of initial variables
char initialName(260,35)
globalSeed.enableNoise
globalSeed.useAutomaticSeed
globalSeed.fixedSeed
globalSeed.seed
globalSeed.id_impure
SysData.S_b
SysData.fn
G1.V_b
G1.V_0
G1.angle_0
G1.P_0
G1.Q_0
G1.S_b
G1.fn
G1.displayPF
G1.pwPin.vr
G1.pwPin.vi
G1.pwPin.ir
G1.pwPin.ii
G1.P
G1.Q
G1.order6.V_b
G1.order6.V_0
G1.order6.angle_0
G1.order6.P_0
G1.order6.Q_0
G1.order6.S_b
G1.order6.fn
G1.order6.Sn
G1.order6.Vn
G1.order6.ra
G1.order6.x1d
G1.order6.M
G1.order6.D
G1.order6.delta
G1.order6.der(delta)
G1.order6.w
G1.order6.der(w)
G1.order6.v
G1.order6.P
G1.order6.Q
G1.order6.vf
G1.order6.anglev
G1.order6.vd
G1.order6.vq
G1.order6.id
G1.order6.iq
G1.order6.pe
G1.order6.vf_MB
G1.order6.w_b
G1.order6.S_SBtoMB
G1.order6.I_MBtoSB
G1.order6.V_MBtoSB
G1.order6.Z_MBtoSB
G1.order6.p0
G1.order6.q0
G1.order6.Vt0.re
G1.order6.Vt0.im
G1.order6.S0.re
G1.order6.S0.im
G1.order6.I0.re
G1.order6.I0.im
G1.order6.vr0
G1.order6.vi0
G1.order6.ir0
G1.order6.ii0
G1.order6.xq0
G1.order6.delta0
G1.order6.Vdq0.re
G1.order6.Vdq0.im
G1.order6.Idq0.re
G1.order6.Idq0.im
G1.order6.vd0
G1.order6.vq0
G1.order6.id0
G1.order6.iq0
G1.order6.pm00
G1.order6.xd
G1.order6.xq
G1.order6.x1q
G1.order6.x2d
G1.order6.x2q
G1.order6.T1d0
G1.order6.T1q0
G1.order6.T2d0
G1.order6.T2q0
G1.order6.Taa
G1.order6.e1q
G1.order6.der(e1q)
G1.order6.e1d
G1.order6.der(e1d)
G1.order6.e2q
G1.order6.der(e2q)
G1.order6.e2d
G1.order6.der(e2d)
G1.order6.e2q0
G1.order6.e2d0
G1.order6.e1d0
G1.order6.K1
G1.order6.K2
G1.order6.e1q0
G1.order6.vf00
G1.aVRtypeIII.vfmax
G1.aVRtypeIII.vfmin
G1.aVRtypeIII.K0
G1.aVRtypeIII.T2
G1.aVRtypeIII.T1
G1.aVRtypeIII.Te
G1.aVRtypeIII.Tr
G1.aVRtypeIII.vm
G1.aVRtypeIII.der(vm)
G1.aVRtypeIII.vr
G1.aVRtypeIII.der(vr)
G1.aVRtypeIII.vf1
G1.aVRtypeIII.der(vf1)
G1.aVRtypeIII.limiter1.uMax
G1.aVRtypeIII.limiter1.uMin
G1.aVRtypeIII.limiter1.strict
G1.aVRtypeIII.limiter1.homotopyType
G1.aVRtypeIII.limiter1.limitsAtInit
G1.aVRtypeIII.vref
G1.aVRtypeIII.s0
G1.pss_off.k
G1.sum.nin
G1.sum.k[1]
G1.sum.k[2]
twoWindingTransformer.n.vr
twoWindingTransformer.n.vi
twoWindingTransformer.n.ir
twoWindingTransformer.n.ii
twoWindingTransformer.Sb
twoWindingTransformer.Sn
twoWindingTransformer.V_b
twoWindingTransformer.Vn
twoWindingTransformer.fn
twoWindingTransformer.kT
twoWindingTransformer.x
twoWindingTransformer.r
twoWindingTransformer.Vb2new
twoWindingTransformer.Vb2old
twoWindingTransformer.xT
twoWindingTransformer.rT
pwLine1.p.ir
pwLine1.p.ii
pwLine1.n.vr
pwLine1.n.vi
pwLine1.n.ir
pwLine1.n.ii
pwLine1.R
pwLine1.X
pwLine1.G
pwLine1.B
pwLine1.S_b
pwLine1.t1
pwLine1.t2
pwLine1.opening
pwLine1.displayPF
pwLine1.P12
pwLine1.P21
pwLine1.Q12
pwLine1.Q21
pwLine1.Y.re
pwLine1.Y.im
pwLine1.Z.re
pwLine1.Z.im
pwLine2.p.ir
pwLine2.p.ii
pwLine2.n.ir
pwLine2.n.ii
pwLine2.R
pwLine2.X
pwLine2.G
pwLine2.B
pwLine2.S_b
pwLine2.t1
pwLine2.t2
pwLine2.opening
pwLine2.displayPF
pwLine2.P12
pwLine2.P21
pwLine2.Q12
pwLine2.Q21
pwLine2.Y.re
pwLine2.Y.im
pwLine2.Z.re
pwLine2.Z.im
infiniteBus.V_b
infiniteBus.V_0
infiniteBus.angle_0
infiniteBus.P_0
infiniteBus.Q_0
infiniteBus.S_b
infiniteBus.fn
infiniteBus.P
infiniteBus.Q
infiniteBus.p.ir
infiniteBus.p.ii
infiniteBus.displayPF
normalNoise.y
normalNoise.samplePeriod
normalNoise.enableNoise
normalNoise.y_off
normalNoise.useGlobalSeed
normalNoise.useAutomaticLocalSeed
normalNoise.fixedLocalSeed
normalNoise.startTime
normalNoise.localSeed
normalNoise.actualGlobalSeed
normalNoise.generateNoise
normalNoise.state[1]
normalNoise.state[2]
normalNoise.state[3]
normalNoise.state[4]
normalNoise.r
normalNoise.r_raw
normalNoise.mu
normalNoise.sigma
realExpression.y
B2.V_b
B2.V_0
B2.angle_0
B2.P_0
B2.Q_0
B2.S_b
B2.fn
B2.p.ir
B2.p.ii
B2.displayPF
phi2
V2
B1.V_b
B1.V_0
B1.angle_0
B1.P_0
B1.Q_0
B1.S_b
B1.fn
B1.p.ir
B1.p.ii
B1.displayPF
phi1
V1
B3.V_b
B3.V_0
B3.angle_0
B3.P_0
B3.Q_0
B3.S_b
B3.fn
B3.p.ir
B3.p.ii
B3.V
B3.angle
B3.displayPF
vf
u
sum.nin
sum.u[2]
sum.k[1]
sum.k[2]

double initialValue(260,6)
 -1       1                  0  0  1  1305   # globalSeed.enableNoise
 -1       0                  0  0  1  1305   # globalSeed.useAutomaticSeed
 -1  6.7867967000000000E+07  0  0  1  1306   # globalSeed.fixedSeed
  0       0                  0  0  6  1282   # globalSeed.seed
  0       0                  0  0  6   770   # globalSeed.id_impure
 -1     100                  0  0  1   280   # SysData.S_b
 -1      50                  0  0  1   280   # SysData.fn
 -1     400                  0  0  1   280   # G1.V_b
 -1       1                  0  0  1   280   # G1.V_0
 -1  2.8338500000000000E+01  0  0  1   280   # G1.angle_0
 -1  1.9979990000000000E+03  0  0  1   280   # G1.P_0
 -1  9.6791999999999996E+02  0  0  1   280   # G1.Q_0
  0       0                  0  0  6   256   # G1.S_b
  0       0                  0  0  6   256   # G1.fn
 -1       1                  0  0  1   281   # G1.displayPF
  0       0                  0  0  6   260   # G1.pwPin.vr
  0       0                  0  0  6   260   # G1.pwPin.vi
  0       0                  0  0  6   388   # G1.pwPin.ir
  0       0                  0  0  6   388   # G1.pwPin.ii
  0       0                  0  0  6   256   # G1.P
  0       0                  0  0  6   256   # G1.Q
  0       0                  0  0  6   256   # G1.order6.V_b
  0       0                  0  0  6   256   # G1.order6.V_0
  0       0                  0  0  6   256   # G1.order6.angle_0
  0       0                  0  0  6   256   # G1.order6.P_0
  0       0                  0  0  6   256   # G1.order6.Q_0
  0       0                  0  0  6   256   # G1.order6.S_b
  0       0                  0  0  6   256   # G1.order6.fn
 -1    2220                  0  0  1   280   # G1.order6.Sn
 -1     400                  0  0  1   280   # G1.order6.Vn
 -1  3.0000000000000001E-03  0  0  1   280   # G1.order6.ra
 -1  2.9999999999999999E-01  0  0  1   280   # G1.order6.x1d
 -1       7                  0  0  1   280   # G1.order6.M
  0       5                  0  0  6   256   # G1.order6.D
 -1       0                  0  0  2   272   # G1.order6.delta
  0       0                  0  0  3   256   # G1.order6.der(delta)
 -1       1                  0  0  2   272   # G1.order6.w
  0       0                  0  0  3   256   # G1.order6.der(w)
  0       0                  0  0  6   256   # G1.order6.v
  0       0                  0  0  6   256   # G1.order6.P
  0       0                  0  0  6   256   # G1.order6.Q
  0       0                  0  0  6   256   # G1.order6.vf
  0       0                  0  0  6   256   # G1.order6.anglev
  0       0                  0  0  6   256   # G1.order6.vd
  0       0                  0  0  6   256   # G1.order6.vq
  0       0                  0  0  6   256   # G1.order6.id
  0       0                  0  0  6   256   # G1.order6.iq
  0       0                  0  0  6  1280   # G1.order6.pe
  0       0                  0  0  6  1280   # G1.order6.vf_MB
  0       0                  0  0  6  1280   # G1.order6.w_b
  0       0                  0  0  6  1280   # G1.order6.S_SBtoMB
  0       0                  0  0  6  1280   # G1.order6.I_MBtoSB
  0       0                  0  0  6  1280   # G1.order6.V_MBtoSB
  0       0                  0  0  6  1280   # G1.order6.Z_MBtoSB
  0       0                  0  0  6  1280   # G1.order6.p0
  0       0                  0  0  6  1280   # G1.order6.q0
  0       0                  0  0  6  1280   # G1.order6.Vt0.re
  0       0                  0  0  6  1280   # G1.order6.Vt0.im
  0       0                  0  0  6  1280   # G1.order6.S0.re
  0       0                  0  0  6  1280   # G1.order6.S0.im
  0       0                  0  0  6  1280   # G1.order6.I0.re
  0       0                  0  0  6  1280   # G1.order6.I0.im
  0       0                  0  0  6  1280   # G1.order6.vr0
  0       0                  0  0  6  1280   # G1.order6.vi0
  0       0                  0  0  6  1280   # G1.order6.ir0
  0       0                  0  0  6  1280   # G1.order6.ii0
  0       0                  0  0  6  1280   # G1.order6.xq0
  0       0                  0  0  6  1280   # G1.order6.delta0
  0       0                  0  0  6  1280   # G1.order6.Vdq0.re
  0       0                  0  0  6  1280   # G1.order6.Vdq0.im
  0       0                  0  0  6  1280   # G1.order6.Idq0.re
  0       0                  0  0  6  1280   # G1.order6.Idq0.im
  0       0                  0  0  6  1280   # G1.order6.vd0
  0       0                  0  0  6  1280   # G1.order6.vq0
  0       0                  0  0  6  1280   # G1.order6.id0
  0       0                  0  0  6  1280   # G1.order6.iq0
  0       0                  0  0  6  1280   # G1.order6.pm00
 -1  1.8100000000000001E+00  0  0  1   280   # G1.order6.xd
 -1  1.7600000000000000E+00  0  0  1   280   # G1.order6.xq
 -1  6.5000000000000002E-01  0  0  1   280   # G1.order6.x1q
 -1  2.3000000000000001E-01  0  0  1   280   # G1.order6.x2d
 -1  2.5000000000000000E-01  0  0  1   280   # G1.order6.x2q
 -1       8                  0  0  1   280   # G1.order6.T1d0
 -1       1                  0  0  1   280   # G1.order6.T1q0
 -1  2.9999999999999999E-02  0  0  1   280   # G1.order6.T2d0
 -1  7.0000000000000007E-02  0  0  1   280   # G1.order6.T2q0
 -1  2.0000000000000000E-03  0  0  1   280   # G1.order6.Taa
 -1       0                  0  0  2   272   # G1.order6.e1q
  0       0                  0  0  3   256   # G1.order6.der(e1q)
 -1       0                  0  0  2   272   # G1.order6.e1d
  0       0                  0  0  3   256   # G1.order6.der(e1d)
 -1       0                  0  0  2   272   # G1.order6.e2q
  0       0                  0  0  3   256   # G1.order6.der(e2q)
 -1       0                  0  0  2   272   # G1.order6.e2d
  0       0                  0  0  3   256   # G1.order6.der(e2d)
  0       0                  0  0  6  1280   # G1.order6.e2q0
  0       0                  0  0  6  1280   # G1.order6.e2d0
  0       0                  0  0  6  1280   # G1.order6.e1d0
  0       0                  0  0  6  1280   # G1.order6.K1
  0       0                  0  0  6  1280   # G1.order6.K2
  0       0                  0  0  6  1280   # G1.order6.e1q0
  0       0                  0  0  6  1280   # G1.order6.vf00
 -1       7                  0  0  1   280   # G1.aVRtypeIII.vfmax
 -1 -6.4000000000000004E+00  0  0  1   280   # G1.aVRtypeIII.vfmin
 -1      10                  0  0  1   280   # G1.aVRtypeIII.K0
 -1       1                  0  0  1   280   # G1.aVRtypeIII.T2
 -1       1                  0  0  1   280   # G1.aVRtypeIII.T1
 -1  1.0000000000000000E-04  0  0  1   280   # G1.aVRtypeIII.Te
 -1  1.4999999999999999E-02  0  0  1   280   # G1.aVRtypeIII.Tr
 -1       0                  0  0  2   272   # G1.aVRtypeIII.vm
  0       0                  0  0  3   256   # G1.aVRtypeIII.der(vm)
 -1       0                  0  0  2   272   # G1.aVRtypeIII.vr
  0       0                  0  0  3   256   # G1.aVRtypeIII.der(vr)
 -1       0                  0  0  2   272   # G1.aVRtypeIII.vf1
  0       0                  0  0  3   256   # G1.aVRtypeIII.der(vf1)
  0       1                  0  0  6   256   # G1.aVRtypeIII.limiter1.uMax
  0       0                  0  0  6   256   # G1.aVRtypeIII.limiter1.uMin
  0       0                  0  0  6   257   # G1.aVRtypeIII.limiter1.strict
  0       2                  1  4  6   258   # G1.aVRtypeIII.limiter1.homotopyType
  0       1                  0  0  6   257   # G1.aVRtypeIII.limiter1.limitsAtInit
  0       0                  0  0  6  1280   # G1.aVRtypeIII.vref
  0       0                  0  0  6  1280   # G1.aVRtypeIII.s0
 -1       0                  0  0  1   280   # G1.pss_off.k
  0       2                  0  0  6   258   # G1.sum.nin
 -1       1                  0  0  1   280   # G1.sum.k[1]
 -1       1                  0  0  1   280   # G1.sum.k[2]
  0       0                  0  0  6   260   # twoWindingTransformer.n.vr
  0       0                  0  0  6   260   # twoWindingTransformer.n.vi
  0       0                  0  0  6   388   # twoWindingTransformer.n.ir
  0       0                  0  0  6   388   # twoWindingTransformer.n.ii
  0       0                  0  0  6   256   # twoWindingTransformer.Sb
 -1    2220                  0  0  1   280   # twoWindingTransformer.Sn
 -1     400                  0  0  1   280   # twoWindingTransformer.V_b
 -1     400                  0  0  1   280   # twoWindingTransformer.Vn
  0       0                  0  0  6   256   # twoWindingTransformer.fn
 -1       1                  0  0  1   280   # twoWindingTransformer.kT
 -1  1.4999999999999999E-01  0  0  1   280   # twoWindingTransformer.x
 -1       0                  0  0  1   280   # twoWindingTransformer.r
  0       0                  0  0  6  1280   # twoWindingTransformer.Vb2new
  0       0                  0  0  6  1280   # twoWindingTransformer.Vb2old
  0       0                  0  0  6  1280   # twoWindingTransformer.xT
  0       0                  0  0  6  1280   # twoWindingTransformer.rT
  0       0                  0  0  6   388   # pwLine1.p.ir
  0       0                  0  0  6   388   # pwLine1.p.ii
  0       0                  0  0  6   260   # pwLine1.n.vr
  0       0                  0  0  6   260   # pwLine1.n.vi
  0       0                  0  0  6   388   # pwLine1.n.ir
  0       0                  0  0  6   388   # pwLine1.n.ii
 -1       0                  0  0  1   280   # pwLine1.R
 -1  2.2522522522522521E-02  0  0  1   280   # pwLine1.X
 -1       0                  0  0  1   280   # pwLine1.G
 -1       0                  0  0  1   280   # pwLine1.B
  0       0                  0  0  6   256   # pwLine1.S_b
  0  9.9999999999999995E+59  0  0  6   256   # pwLine1.t1
  0  9.9999999999999995E+59  0  0  6   256   # pwLine1.t2
  0       1                  0  0  6   258   # pwLine1.opening
 -1       0                  0  0  1   281   # pwLine1.displayPF
  0       0                  0  0  6   256   # pwLine1.P12
  0       0                  0  0  6   256   # pwLine1.P21
  0       0                  0  0  6   256   # pwLine1.Q12
  0       0                  0  0  6   256   # pwLine1.Q21
  0       0                  0  0  6  1280   # pwLine1.Y.re
  0       0                  0  0  6  1280   # pwLine1.Y.im
  0       0                  0  0  6  1280   # pwLine1.Z.re
  0       0                  0  0  6  1280   # pwLine1.Z.im
  0       0                  0  0  6   388   # pwLine2.p.ir
  0       0                  0  0  6   388   # pwLine2.p.ii
  0       0                  0  0  6   388   # pwLine2.n.ir
  0       0                  0  0  6   388   # pwLine2.n.ii
 -1       0                  0  0  1   280   # pwLine2.R
 -1  4.1891891891891894E-02  0  0  1   280   # pwLine2.X
 -1       0                  0  0  1   280   # pwLine2.G
 -1       0                  0  0  1   280   # pwLine2.B
  0       0                  0  0  6   256   # pwLine2.S_b
  0  9.9999999999999995E+59  0  0  6   256   # pwLine2.t1
  0  9.9999999999999995E+59  0  0  6   256   # pwLine2.t2
  0       1                  0  0  6   258   # pwLine2.opening
 -1       0                  0  0  1   281   # pwLine2.displayPF
  0       0                  0  0  6   256   # pwLine2.P12
  0       0                  0  0  6   256   # pwLine2.P21
  0       0                  0  0  6   256   # pwLine2.Q12
  0       0                  0  0  6   256   # pwLine2.Q21
  0       0                  0  0  6  1280   # pwLine2.Y.re
  0       0                  0  0  6  1280   # pwLine2.Y.im
  0       0                  0  0  6  1280   # pwLine2.Z.re
  0       0                  0  0  6  1280   # pwLine2.Z.im
 -1     400                  0  0  1   280   # infiniteBus.V_b
 -1  9.0081000000000000E-01  0  0  1   280   # infiniteBus.V_0
 -1       0                  0  0  1   280   # infiniteBus.angle_0
 -1   -1998                  0  0  1   280   # infiniteBus.P_0
 -1  8.7066000000000003E+01  0  0  1   280   # infiniteBus.Q_0
  0       0                  0  0  6   256   # infiniteBus.S_b
  0       0                  0  0  6   256   # infiniteBus.fn
  0       0                  0  0  6   256   # infiniteBus.P
  0       0                  0  0  6   256   # infiniteBus.Q
  0       0                  0  0  6   388   # infiniteBus.p.ir
  0       0                  0  0  6   388   # infiniteBus.p.ii
 -1       0                  0  0  1   281   # infiniteBus.displayPF
  0       0                  0  0  6   320   # normalNoise.y
 -1  1.0000000000000000E-02  0  0  1   280   # normalNoise.samplePeriod
  0       0                  0  0  6   257   # normalNoise.enableNoise
 -1       0                  0  0  1   280   # normalNoise.y_off
 -1       1                  0  0  1   281   # normalNoise.useGlobalSeed
 -1       1                  0  0  1   281   # normalNoise.useAutomaticLocalSeed
 -1       1                  0  0  1   282   # normalNoise.fixedLocalSeed
 -1       0                  0  0  1   280   # normalNoise.startTime
  0       0                  0  0  6   258   # normalNoise.localSeed
  0       0                  0  0  6  1282   # normalNoise.actualGlobalSeed
  0       0                  0  0  6  1281   # normalNoise.generateNoise
  0       0                  0  0  6  1346   # normalNoise.state[1]
  0       0                  0  0  6  1346   # normalNoise.state[2]
  0       0                  0  0  6  1346   # normalNoise.state[3]
  0       0                  0  0  6  1346   # normalNoise.state[4]
  0       0                  0  0  6  1344   # normalNoise.r
  0       0                  0  0  6  1344   # normalNoise.r_raw
 -1       0                  0  0  1   280   # normalNoise.mu
 -1       1                  0  0  1   280   # normalNoise.sigma
  0       0                  0  0  6   256   # realExpression.y
 -1     400                  0  0  1   280   # B2.V_b
 -1       1                  0  0  1   280   # B2.V_0
 -1       0                  0  0  1   280   # B2.angle_0
 -1       1                  0  0  1   280   # B2.P_0
 -1       0                  0  0  1   280   # B2.Q_0
  0       0                  0  0  6   256   # B2.S_b
  0       0                  0  0  6   256   # B2.fn
  0       0                  0  0  6   388   # B2.p.ir
  0       0                  0  0  6   388   # B2.p.ii
 -1       1                  0  0  1   281   # B2.displayPF
  0       0                  0  0  4   256   # phi2
  0       0                  0  0  4   256   # V2
 -1     400                  0  0  1   280   # B1.V_b
 -1       1                  0  0  1   280   # B1.V_0
 -1       0                  0  0  1   280   # B1.angle_0
 -1       1                  0  0  1   280   # B1.P_0
 -1       0                  0  0  1   280   # B1.Q_0
  0       0                  0  0  6   256   # B1.S_b
  0       0                  0  0  6   256   # B1.fn
  0       0                  0  0  6   388   # B1.p.ir
  0       0                  0  0  6   388   # B1.p.ii
 -1       1                  0  0  1   281   # B1.displayPF
  0       0                  0  0  4   256   # phi1
  0       0                  0  0  4   256   # V1
 -1     400                  0  0  1   280   # B3.V_b
 -1       1                  0  0  1   280   # B3.V_0
 -1       0                  0  0  1   280   # B3.angle_0
 -1       1                  0  0  1   280   # B3.P_0
 -1       0                  0  0  1   280   # B3.Q_0
  0       0                  0  0  6   256   # B3.S_b
  0       0                  0  0  6   256   # B3.fn
  0       0                  0  0  6   388   # B3.p.ir
  0       0                  0  0  6   388   # B3.p.ii
  0       0                  0  0  6   256   # B3.V
  0       0                  0  0  6   256   # B3.angle
 -1       1                  0  0  1   281   # B3.displayPF
  0       0                  0  0  4   256   # vf
  0       0                  0  0  4   320   # u
  0       2                  0  0  6   258   # sum.nin
  0       0                  0  0  6   256   # sum.u[2]
 -1       1                  0  0  1   280   # sum.k[1]
 -1       1                  0  0  1   280   # sum.k[2]


# Matrix with 6 columns defining the initial value calculation
# (columns 5 and 6 are not utilized for the calculation but are
#  reported by dymosim via dymosim -i for user convenience):
#
# column 1: Type of initial value
#           = -2: special case: for continuing simulation (column 2 = value)
#           = -1: fixed value (column 2 = fixed value)
#           =  0: free value, i.e., no restriction (column 2 = initial value)
#           >  0: desired value (column 1 = weight for optimization
#                                column 2 = desired value)
#                 use weight=1, since automatic scaling usually
#                 leads to equally weighted terms
# column 2: fixed, free or desired value according to column 1.
# column 3: Minimum value (ignored, if Minimum >= Maximum).
# column 4: Maximum value (ignored, if Minimum >= Maximum).
#           Minimum and maximum restrict the search range in initial
#           value calculation. They might also be used for scaling.
# column 5: Category of variable.
#           = 1: parameter.
#           = 2: state.
#           = 3: state derivative.
#           = 4: output.
#           = 5: input.
#           = 6: auxiliary variable.
# column 6: Data type of variable and flags according to dsBaseType
#  <value>&3= 0: real.
#  <value>&3= 1: boolean.
#  <value>&3= 2: integer.
#
# Initial values are calculated according to the following procedure:
#
# - If parameters, states and inputs are FIXED, and other variables
#   are FREE, no special action takes place (default setting).
#
# - If there are only FIXED and FREE variables and the number of
#   FREE parameters, states and inputs is IDENTICAL to the number of
#   FIXED state derivatives, outputs and auxiliary variables, a non-linear
#   equation is solved to determine a consistent set of initial conditions.
#
# - In all other cases the following optimization problem is solved:
#      min( sum( weight(i)*( (value(i) - DESIRED(i))/scale(i) )^2 ) )
#   under the constraint that the differential equation is fulfilled
#   at the initial time. In most cases weight(i)=1 is sufficient, due
#   to the automatic scaling (if DESIRED(i) is not close to zero,
#   scale(i) = DESIRED(i). Otherwise, the scaling is based on the
#   nominal value (and maybe minimum and maximum values given in 
#   column 3 and 4). If these values are zero, scale(i)=1 is used).
#
char initialDescription(260,139)
= true, if noise blocks generate noise as output; = false, if they generate a constant output [:#(type=Boolean)]
= true, choose a seed by system time and process id; = false, use fixedSeed [:#(type=Boolean)]
Fixed global seed for random number generators (if useAutomaticSeed = false) [:#(type=Integer)]
Actually used global seed [:#(type=Integer)]
ID for impure random number generators Modelica.Math.Random.Utilities.impureXXX [:#(type=Integer)]
System base [MVA]
System Frequency [Hz]
Base voltage of the bus [kV]
Voltage magnitude (pu) [1]
Voltage angle [deg]
Active power [MW]
Reactive power [Mvar]
System base power [MVA]
System Frequeny [Hz]
Display power flow results: [:#(type=Boolean)]
Real part of the voltage [1]
Imaginary part of the voltage [1]
Real part of the current [1]
Imaginary part of the current [1]
Active power [MW]
Reactive power [Mvar]
Base voltage of the bus [kV]
Voltage magnitude (pu) [1]
Voltage angle [deg]
Active power [MW]
Reactive power [Mvar]
System base power [MVA]
System Frequeny [Hz]
Power rating (MVA) [MVA]
Voltage rating (kV) [kV]
Armature resistance (pu) [1]
d-axis transient reactance (pu) [1]
Mechanical starting time (2H), kWs/kVA
Damping coefficient
Rotor angle (rad) [rad|rad]
der(Rotor angle (rad)) [rad/s]
Rotor speed (pu) [1]
der(Rotor speed (pu)) [s-1]
Generator terminal voltage (pu) [1]
Active power (pu) [1]
Reactive power (pu) [1]
Field voltage (pu) [1]
 Bus voltage angle (rad) [rad|deg]
d-axis voltage (pu) [1]
q-axis voltage (pu) [1]
d-axis currrent (pu) [1]
q-axis current (pu) [1]
electrical power transmitted through the air-gap [1]
field voltage on machine base [1]
Base frequency in rad/s [rad/s]
S(system base) -> S(machine base) [1]
I(machine base) -> I(system base) [1]
V(machine base) -> V(system base) [1]
Z(machine base) -> Z(system base) [1]
Initial active power generation in pu (system base) [1]
Initial reactive power generation in pu (system base) [1]
Real part of complex number
Imaginary part of complex number
Real part of complex number [1]
Imaginary part of complex number [1]
Real part of complex number
Imaginary part of complex number
Init. val. [1]
Init. val. [1]
Init. val. [1]
Init. val. [1]
used for setting the initial rotor angle [1]
Init. val. rotor angle [rad|deg]
Real part of complex number
Imaginary part of complex number
Real part of complex number
Imaginary part of complex number
Init. val. [1]
Init. val. [1]
Init. val. [1]
Init. val. [1]
Init. val. (pu, system base) [1]
d-axis synchronous reactance (pu) [1]
q-axis synchronous reactance (pu) [1]
q-axis transient reactance (pu) [1]
d-axis sub-transient reactance (pu) [1]
q-axis sub-transient reactance (pu) [1]
d-axis open circuit transient time constant (s)
q-axis open circuit transient time constant (s)
d-axis open circuit transient time constant (s)
q-axis open circuit transient time constant (s)
d-axis aditional leakage time constant (s)
q-axis transient voltage [1]
der(q-axis transient voltage) [s-1]
d-axis transient voltage [1]
der(d-axis transient voltage) [s-1]
q-axis sub-transient voltage [1]
der(q-axis sub-transient voltage) [s-1]
d-axis sub-transient voltage [1]
der(d-axis sub-transient voltage) [s-1]
Initialitation [1]
Initialitation [1]
[1]
[1]
[1]
[1]
Init. val. (pu, SB) [1]
[1]
[1]
regulator gain
regulator pole
Regulator zero
Field circuit time constant
Measurement time constant
[1]
[s-1]
[1]
[s-1]
[1]
[s-1]
Upper limits of input signals [1]
Lower limits of input signals [1]
= true, if strict limits with noEvent(..) [:#(type=Boolean)]
Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]
Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]
[1]
[1]
Constant output value [1]
Number of inputs [:#(type=Integer)]
Optional: sum coefficients
Optional: sum coefficients
Real part of the voltage [1]
Imaginary part of the voltage [1]
Real part of the current
Imaginary part of the current
System base power (MVA) [MVA]
Power rating (MVA)
Sending end bus voltage (kV)
Voltage rating (kV)
Frequency rating (Hz) [Hz]
Nominal tap ratio (kV1/kV2)
Reactance (pu machine base)
Resistance (pu machine base)


Reactance, p.u system base
Resistance, p.u system base
Real part of the current
Imaginary part of the current
Real part of the voltage
Imaginary part of the voltage
Real part of the current
Imaginary part of the current
Resistance (pu) [1]
Reactance (pu) [1]
Shunt half conductance (pu) [1]
Shunt half susceptance (pu) [1]
System base power (MVA) [MVA]
[s]
[s]
[:#(type=Integer)]
Display power flow results: [:#(type=Boolean)]
[MW]
[MW]
[Mvar]
[Mvar]
Real part of complex number [1]
Imaginary part of complex number [1]
Real part of complex number [1]
Imaginary part of complex number [1]
Real part of the current
Imaginary part of the current
Real part of the current
Imaginary part of the current
Resistance (pu) [1]
Reactance (pu) [1]
Shunt half conductance (pu) [1]
Shunt half susceptance (pu) [1]
System base power (MVA) [MVA]
[s]
[s]
[:#(type=Integer)]
Display power flow results: [:#(type=Boolean)]
[MW]
[MW]
[Mvar]
[Mvar]
Real part of complex number [1]
Imaginary part of complex number [1]
Real part of complex number [1]
Imaginary part of complex number [1]
Base voltage of the bus [kV]
Voltage magnitude (pu) [1]
Voltage angle [deg]
Active power [MW]
Reactive power [Mvar]
System base power [MVA]
System Frequeny [Hz]
Active Power absorbed by the Infinite bus (MW)
Reactive Power absorbed by the Infinite bus (MVAr)
Real part of the current
Imaginary part of the current
Display power flow results: [:#(type=Boolean)]
Connector of Real output signal
Period for sampling the raw random numbers [s]
=true: y = noise, otherwise y = y_off [:#(type=Boolean)]
y = y_off if enableNoise=false (or time<startTime, see below)
= true: use global seed, otherwise ignore it [:#(type=Boolean)]
= true: use automatic local seed, otherwise use fixedLocalSeed [:#(type=Boolean)]
Local seed (any Integer number) [:#(type=Integer)]
Start time for sampling the raw random numbers [s]
The actual localSeed [:#(type=Integer)]
The global seed, which is actually used [:#(type=Integer)]
= true if noise shall be generated, otherwise no noise [:#(type=Boolean)]
Internal state of random number generator [:#(type=Integer)]
Internal state of random number generator [:#(type=Integer)]
Internal state of random number generator [:#(type=Integer)]
Internal state of random number generator [:#(type=Integer)]
Random number according to the desired distribution
Uniform random number in the range (0,1] []
Expectation (mean) value of the normal distribution
Standard deviation of the normal distribution
Value of Real output
Base voltage of the bus [kV]
Voltage magnitude (pu) [1]
Voltage angle [deg]
Active power [MW]
Reactive power [Mvar]
System base power [MVA]
System Frequeny [Hz]
Real part of the current
Imaginary part of the current
Display voltage values: [:#(type=Boolean)]
[deg]
[1]
Base voltage of the bus [kV]
Voltage magnitude (pu) [1]
Voltage angle [deg]
Active power [MW]
Reactive power [Mvar]
System base power [MVA]
System Frequeny [Hz]
Real part of the current [1]
Imaginary part of the current [1]
Display voltage values: [:#(type=Boolean)]
[deg]
[1]
Base voltage of the bus [kV]
Voltage magnitude (pu) [1]
Voltage angle [deg]
Active power [MW]
Reactive power [Mvar]
System base power [MVA]
System Frequeny [Hz]
Real part of the current
Imaginary part of the current
Bus voltage magnitude (pu) [1]
Bus voltage angle [deg]
Display voltage values: [:#(type=Boolean)]
[1]

Number of inputs [:#(type=Integer)]
Connector of Real input signals
Optional: sum coefficients
Optional: sum coefficients

